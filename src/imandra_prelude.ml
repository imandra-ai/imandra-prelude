(* generated by imandra-extract from "prelude.iml" *)
#6 "prelude.iml"
type 'a printer = Format.formatter -> 'a -> unit
#7 "prelude.iml"
module Caml =
  struct
    include Stdlib
    type use_normal_equality
    type nonrec 'a list = 'a list =
      | [] 
      | (::) of 'a * 'a list 
    let (==) _ _ = (assert false : use_normal_equality)
    let (!=) _ _ = (assert false : use_normal_equality)
    module String =
      struct
        include String
        let prefix pre s = CCString.prefix ~pre s
        let suffix a b = CCString.suffix ~suf:a b
        let contains a ~sub  = CCString.mem ~sub a
        let unsafe_to_nat s =
          try
            let n = Z.of_string s in if Z.lt n Z.zero then Z.minus_one else n
          with | _ -> Z.minus_one
      end
    module Char = Char
    module List = List
    module Array = Array
    module Set = Set
    module Map = Map
    module Printf = Printf
    module Format = CCFormat
    let float_of_string = float_of_string
    let count_function_actual_implem (_ : 'a) =
      (failwith
         "the `count` function is not evaluable, its only purpose is helping proving termination of functions in Logic mode" : 
      'b)
    let sleep = Unix.sleep
    module Int :
      sig
        type t = int
        val (+) : t -> t -> t
        val (-) : t -> t -> t
        val (~-) : t -> t
        val ( * ) : t -> t -> t
        val (/) : t -> t -> t
        val (mod) : t -> t -> t
        val (<) : t -> t -> bool
        val (<=) : t -> t -> bool
        val (>) : t -> t -> bool
        val (>=) : t -> t -> bool
        val min : t -> t -> t
        val max : t -> t -> t
        val incr : t ref -> unit
        val decr : t ref -> unit
        val succ : t -> t
        val pred : t -> t
        val of_int : int -> t
      end = struct type t = int
                   include Stdlib
                   let of_int i = i end 
  end
#72 "prelude.iml"
module Imandra_caml = Caml
#75 "prelude.iml"
module Caml_unix = Unix
#76 "prelude.iml"
module Caml_sys = Sys
#82 "prelude.iml"
[@@@ocaml.text " {2 Bare minimum needed for ordinals and validation} "]
#94 "prelude.iml"
type nonrec int = Z.t[@@ocaml.doc
                       " Builtin integer type, using arbitrary precision integers.\n\n    This type is an alias to {!Z.t}\n    (using {{: https://github.com/ocaml/Zarith} Zarith}).\n\n    {b NOTE}: here Imandra diverges from normal OCaml, where integers width\n    is bounded by native machine integers.\n    \"Normal\" OCaml integers have type {!Caml.Int.t} and can be entered\n    using the 'i' suffix: [0i]\n"]
#97 "prelude.iml"
let (=) = Stdlib.(=)[@@ocaml.doc
                      " Equality. Must be applied to non-function types. "]
#98 "prelude.iml"
let (<>) = Stdlib.(<>)
#100 "prelude.iml"
let not = let open Stdlib in not
#101 "prelude.iml"
let implies x y = if x then y else true
#102 "prelude.iml"
let explies x y = implies y x
#103 "prelude.iml"
let iff x y = (implies x y) && (implies y x)
#107 "prelude.iml"
let (+) = Z.(+)
#111 "prelude.iml"
let const x _ = x[@@ocaml.doc
                   " [const x y] returns [x]. In other words, [const x] is\n    the constant function that always returns [x]. "]
#113 "prelude.iml"
let (>=) : int -> int -> bool = (>=)
#116 "prelude.iml"
type nonrec nativeint = nativeint[@@opaque ]
#118 "prelude.iml"
let mk_nat (x : int) =
  (if x >= (Z.of_nativeint 0n) then x else Z.of_nativeint 0n : int)
#122 "prelude.iml"
type nonrec 'a option = 'a option =
  | None 
  | Some of 'a [@@noalias ]
#124 "prelude.iml"
type 'a list = 'a Caml.list =
  | [] 
  | (::) of 'a * 'a list [@@noalias ]
#126 "prelude.iml"
type nonrec float = float
#128 "prelude.iml"
type nonrec real = Q.t
#132 "prelude.iml"
type nonrec string = string
#135 "prelude.iml"
let (<) : int -> int -> bool = (<)
#136 "prelude.iml"
let (<=) : int -> int -> bool = (<=)
#137 "prelude.iml"
let (>) : int -> int -> bool = (>)
#138 "prelude.iml"
let min : int -> int -> int = min
#139 "prelude.iml"
let max : int -> int -> int = max
#141 "prelude.iml"
let (<.) : real -> real -> bool = Q.lt
#142 "prelude.iml"
let (<=.) : real -> real -> bool = Q.leq
#143 "prelude.iml"
let (>.) : real -> real -> bool = Q.gt
#144 "prelude.iml"
let (>=.) : real -> real -> bool = Q.geq
#145 "prelude.iml"
let min_r : real -> real -> real = Q.min
#146 "prelude.iml"
let max_r : real -> real -> real = Q.max
#148 "prelude.iml"
let (~-) = Z.(~-)
#149 "prelude.iml"
let abs (x : int) = if x >= (Z.of_nativeint 0n) then x else - x
#151 "prelude.iml"
let (-) = Z.(-)
#152 "prelude.iml"
let (~+) (x : Z.t) = x
#153 "prelude.iml"
let ( * ) = Z.( * )
#157 "prelude.iml"
let (/) = Z.ediv[@@ocaml.doc
                  " Euclidian division on integers,\n    see {{: http://smtlib.cs.uiowa.edu/theories-Ints.shtml} http://smtlib.cs.uiowa.edu/theories-Ints.shtml} "]
#160 "prelude.iml"
let (mod) = Z.erem[@@ocaml.doc " Euclidian remainder on integers "]
#163 "prelude.iml"
let compare (x : int) (y : int) =
  if x = y
  then Z.of_nativeint 0n
  else if x < y then Z.of_nativeint (-1n) else Z.of_nativeint 1n[@@ocaml.doc
                                                                  " Total order "]
#165 "prelude.iml"
[@@@ocaml.text " {2 Ordinals} "]
#170 "prelude.iml"
module Ordinal :
  sig
    type t =
      | Int of int 
      | Cons of t * int * t 
    val pp : Format.formatter -> t -> unit
    val of_int : int -> t
    val (~$) : int -> t
    val (<<) : t -> t -> bool
    val plus : t -> t -> t
    val simple_plus : t -> t -> t
    val (+) : t -> t -> t
    val of_list : t list -> t
    val pair : t -> t -> t
    val triple : t -> t -> t -> t
    val quad : t -> t -> t -> t -> t
    val shift : t -> by:t -> t
    val is_valid : t -> bool
    val is_valid_rec : t -> bool
    val zero : t
    val one : t
    val omega : t
    val omega_omega : t
  end =
  struct
    type t =
      | Int of int 
      | Cons of t * int * t
      [@ocaml.doc
        " [cons a x tl] is [x\194\183(\207\137^a) + tl], where [tl < \207\137\194\183a], [a\226\137\1600], [x\226\137\1600] "]
    [@@ocaml.doc
      " Ordinals, up to \206\181\226\130\128, in Cantor Normal Form "]
    let pp out (x : t) =
      (let pp_coeff out x =
         if Z.equal Z.one x
         then ()
         else Format.fprintf out "%a@<1>\194\183" Z.pp_print x in
       let rec pp out =
         function
         | Int x -> Z.pp_print out x
         | Cons (a, x, tl) ->
             Format.fprintf out "%a@<1>\207\137%a%a" pp_coeff x pp_power a
               pp_tail tl
       and pp_tail out =
         function
         | Int n when Z.equal Z.zero n -> ()
         | x -> Format.fprintf out "@ + %a" pp x
       and pp_power out =
         function
         | Int n when Z.equal Z.one n -> ()
         | x -> Format.fprintf out "^%a" pp_inner x
       and pp_inner out x =
         match x with
         | Int _ -> pp out x
         | Cons _ -> Format.fprintf out "(@[%a@])" pp x in
       Format.fprintf out "@[%a@]" pp x : unit)[@@program ]
    let of_int_unsafe (x : int) = (Int x : t)
    let zero = Int (Z.of_nativeint 0n)
    let one = Int (Z.of_nativeint 1n)
    let two = Int (Z.of_nativeint 2n)
    let of_int (x : int) = (of_int_unsafe (mk_nat x) : t)
    let rec (<<) (x : t) (y : t) =
      (match (x, y) with
       | (Int x, Int y) -> x < y
       | (Int _, Cons _) -> true
       | (Cons _, Int _) -> false
       | (Cons (a1, x1, tl1), Cons (a2, x2, tl2)) ->
           (a1 << a2) ||
             ((a1 = a2) && ((x1 < x2) || ((x1 = x2) && (tl1 << tl2)))) : 
      bool)[@@ocaml.doc
             " Special axiom: the original well founded relation we use\n      for proving all the other functions terminating. "]
    let rec plus (x : t) (y : t) =
      (match (x, y) with
       | (Int x, Int y) -> Int (x + y)
       | (Int _, Cons _) -> y
       | (Cons (a, x, tl), Int _) -> Cons (a, x, (plus tl y))
       | (Cons (a1, x1, tl1), Cons (a2, x2, tl2)) ->
           if a1 << a2
           then y
           else
             if a1 = a2
             then Cons (a1, (x1 + x2), tl2)
             else Cons (a1, x1, (plus tl1 y)) : t)[@@ocaml.doc
                                                    " Addition of ordinals. Not commutative. "]
    let rec shift (x : t) ~by:(n : t)  =
      (if (n = (Int (Z.of_nativeint 0n))) || (x = (Int (Z.of_nativeint 0n)))
       then x
       else
         (match x with
          | Int x -> Cons (n, x, zero)
          | Cons (a, x, tl) -> Cons ((plus a n), x, (shift tl ~by:n))) : 
      t)
    let pair (x : t) (y : t) =
      (match x with
       | Int x -> Cons (one, (x + (Z.of_nativeint 1n)), y)
       | Cons (a, x, _tl) -> Cons ((plus a one), x, y) : t)
    let triple x y z = pair x (pair y z)
    let quad x y z w = pair x (triple y z w)
    let simple_plus (x : t) (y : t) =
      (match (x, y) with
       | (Int a, Int b) -> Int (a + b)
       | _ -> Int (Z.of_nativeint 0n) : t)
    let rec of_list_rec (acc : t) (l : t list) =
      (match l with
       | [] -> acc
       | x::tail -> of_list_rec (plus (shift acc ~by:one) x) tail : t)
    let of_list (l : t list) =
      (match l with
       | [] -> zero
       | x::[] -> x
       | x::y::[] -> plus (shift ~by:one x) y
       | x::y::z::[] -> plus (shift ~by:two x) (plus (shift ~by:one y) z)
       | x::y::z::tl ->
           of_list_rec (plus (shift ~by:two x) (plus (shift ~by:one y) z)) tl : 
      t)
    let rec is_valid_rec (x : t) =
      (match x with
       | Int x -> x >= (Z.of_nativeint 0n)
       | Cons (a, x, tl) ->
           (is_valid_rec a) &&
             ((a <> zero) &&
                ((x > (Z.of_nativeint 0n)) &&
                   ((is_valid_rec tl) &&
                      ((match tl with
                        | Cons (b, _, _) -> b << a
                        | Int _ -> true))))) : bool)[@@ocaml.doc
                                                      " Is this a valid ordinal? "]
    let is_valid (x : t) =
      (match x with | Int x -> x >= (Z.of_nativeint 0n) | o -> is_valid_rec o : 
      bool)[@@ocaml.doc " Is this a valid ordinal? "]
    let (+) = plus
    let (~$) = of_int
    let omega = of_list [one; zero]
    let omega_omega = shift omega omega
  end [@@ocaml.doc
        " We need to define ordinals before any recursive function is defined,\n    because ordinals are used for termination proofs.\n"]
#368 "prelude.iml"
module Peano_nat =
  struct
    type t =
      | Z 
      | S of t 
    let zero = Z
    let succ x = S x
    let rec of_int i =
      (if i <= (Z.of_nativeint 0n)
       then Z
       else S (of_int (i - (Z.of_nativeint 1n))) : t)[@@ocaml.doc
                                                       " Turn this integer into a natural number. Negative integers map to zero. "]
    let rec to_int x =
      (match x with
       | Z -> Z.of_nativeint 0n
       | S y -> (Z.of_nativeint 1n) + (to_int y) : int)[@@ocaml.doc
                                                         " Turn this natural number into a native integer. "]
    let rec plus x y = match x with | Z -> y | S x' -> S (plus x' y)[@@ocaml.doc
                                                                    " Peano addition "]
    let rec leq x y =
      match (x, y) with
      | (Z, _) -> true
      | (_, Z) -> false
      | (S x', S y') -> leq x' y'[@@ocaml.doc " Comparison "]
    let (=) = (=)
    let (<=) = leq
    let (+) = plus
  end[@@ocaml.doc " {2 Natural numbers} "]
#403 "prelude.iml"
[@@@ocaml.text " {2 Other builtin types} "]
#405 "prelude.iml"
type nonrec unit = unit =
  | () [@@noalias ]
#409 "prelude.iml"
type ('a, 'b) result = ('a, 'b) Stdlib.result =
  | Ok of 'a 
  | Error of 'b [@@ocaml.doc
                  " Result type, representing either a successul result [Ok x]\n    or an error [Error x]. "]
[@@noalias ]
#411 "prelude.iml"
module Result =
  struct
    type ('a, 'b) t = ('a, 'b) result
    let return x = Ok x
    let fail s = Error s
    let map f e = match e with | Ok x -> Ok (f x) | Error s -> Error s
    let map_err f e = match e with | Ok x -> Ok x | Error y -> Error (f y)
    let get_or e ~default  = match e with | Ok x -> x | Error _ -> default
    let map_or f e ~default  =
      match e with | Ok x -> f x | Error _ -> default
    let (>|=) e f = map f e
    let flat_map f e = match e with | Ok x -> f x | Error s -> Error s
    let (>>=) e f = flat_map f e
    let fold ~ok  ~error  x =
      match x with | Ok x -> ok x | Error s -> error s
    let is_ok = function | Ok _ -> true | Error _ -> false
    let is_error = function | Ok _ -> false | Error _ -> true
    let monoid_product a b =
      match (a, b) with
      | (Ok x, Ok y) -> Ok (x, y)
      | (Error e, _) -> Error e
      | (_, Error e) -> Error e
    let (let+) = (>|=)
    let (and+) = monoid_product
    let ( let* ) = (>>=)
    let ( and* ) = monoid_product
  end
#474 "prelude.iml"
type ('a, 'b) either =
  | Left of 'a 
  | Right of 'b [@@ocaml.doc " A familiar type for Haskellers "]
#483 "prelude.iml"
let (|>) x f = f x[@@ocaml.doc
                    " Pipeline operator.\n\n    [x |> f] is the same as [f x], but it composes nicely:\n    [ x |> f |> g |> h] can be more readable than [h(g(f x))].\n"]
#490 "prelude.iml"
let (@@) f x = f x[@@ocaml.doc
                    " Right-associative application operator.\n\n    [f @@ x] is the same as [f x], but it binds to the right:\n    [f @@ g @@ h @@ x] is the same as [f (g (h x))] but with fewer parentheses.\n"]
#493 "prelude.iml"
let id x = x[@@ocaml.doc " Identity function. [id x = x] always holds. "]
#498 "prelude.iml"
let (%>) f g x = g (f x)[@@ocaml.doc
                          " Mathematical composition operator.\n\n    [f %> g] is [fun x -> g (f x)] "]
#502 "prelude.iml"
let (==) = Caml.(==)[@@program ]
#503 "prelude.iml"
let (!=) = Caml.(!=)[@@program ]
#505 "prelude.iml"
let (+.) : real -> real -> real = Q.(+)
#506 "prelude.iml"
let (-.) : real -> real -> real = Q.(-)
#507 "prelude.iml"
let (~-.) = Q.neg
#508 "prelude.iml"
let ( *. ) : real -> real -> real = Q.( * )
#509 "prelude.iml"
let (/.) : real -> real -> real = Q.(/)
#525 "prelude.iml"
module List =
  struct
    type 'a t = 'a list
    let empty = []
    let is_empty = function | [] -> true | _::_ -> false[@@ocaml.doc
                                                          " Test whether a list is empty "]
    let cons x y = x :: y[@@ocaml.doc
                           " [cons x l] prepends [x] to the beginning of [l], returning a new list "]
    let return x = [x][@@ocaml.doc " Singleton list "]
    let hd x = List.hd x[@@ocaml.doc
                          " Partial function to access the head of the list.\n      This function will fail when applied to the empty list.\n      {b NOTE} it is recommended to rely on pattern matching instead "]
    let tl x = List.tl x[@@ocaml.doc
                          " Partial function to access the tail of the list.\n      This function will fail when applied to the empty list\n      {b NOTE} it is recommended to rely on pattern matching instead "]
    let rec append l1 l2 =
      match l1 with | [] -> l2 | x::l1' -> x :: (append l1' l2)[@@ocaml.doc
                                                                 " List append / concatenation. [append l1 l2] returns a list\n      composed of all elements of [l1], followed by all elements of [l2] "]
    let append_to_nil x = (append x []) = x[@@imandra_theorem ][@@induct x]
      [@@rw ]
    let append_single x y z = (append (append y [x]) z) = (append y (x :: z))
      [@@imandra_theorem ][@@induct y][@@rw ]
    let rec rev l = match l with | [] -> [] | x::l' -> append (rev l') [x]
      [@@ocaml.doc " Reverse a list "]
    let rec length l =
      match l with
      | [] -> Z.of_nativeint 0n
      | _::l2 -> (Z.of_nativeint 1n) + (length l2)[@@ocaml.doc
                                                    " Compute the length of a list. Linear time. "]
    let len_nonnegative l = ((length l)[@trigger ]) >= (Z.of_nativeint 0n)
      [@@imandra_theorem ][@@fc ][@@induct l]
    let len_zero_is_empty x = ((length x) = (Z.of_nativeint 0n)) = (x = [])
      [@@imandra_theorem ][@@rewrite ][@@induct x]
    let rec split l =
      match l with
      | [] -> ([], [])
      | (x, y)::tail ->
          let (tail1, tail2) = split tail in ((x :: tail1), (y :: tail2))
      [@@ocaml.doc " Split a list of pairs into a pair of lists "]
    let rec map f l = match l with | [] -> [] | x::l2 -> (f x) :: (map f l2)
      [@@ocaml.doc
        " Map a function over a list.\n\n      - [map f [] = []]\n      - [map f [x] = [f x]]\n      - [map f (x :: tail) = f x :: map f tail]\n  "]
    let rec map2 f l1 l2 =
      let open Result in
        match (l1, l2) with
        | ([], []) -> Ok []
        | (x::l1, y::l2) -> (map2 f l1 l2) >|= (cons (f x y))
        | (_, _) -> Error "map2: Lengths of l1 and l2 don't match"
    let rec for_all f l =
      match l with | [] -> true | x::l2 -> (f x) && (for_all f l2)[@@ocaml.doc
                                                                    " [for_all f l] tests whether all elements of [l] satisfy the predicate [f] "]
    let rec exists f l =
      match l with | [] -> false | x::l2 -> (f x) || (exists f l2)[@@ocaml.doc
                                                                    " [exists f l] tests whether there is an element of [l]\n      that satisfies the predicate [f] "]
    let rec fold_left f acc =
      function | [] -> acc | x::tail -> fold_left f (f acc x) tail[@@ocaml.doc
                                                                    " Fold-left, with an accumulator that makes induction more challenging "]
    let rec fold_right f ~base  l =
      match l with | [] -> base | x::tail -> f x (fold_right f ~base tail)
      [@@ocaml.doc
        " Fold-right, without accumulator. This is generally more friendly for\n      induction than [fold_left]. "]
    let rec mapi_with ~base  f l =
      match l with
      | [] -> []
      | x::l2 -> (f base x) ::
          (mapi_with ~base:(base + (Z.of_nativeint 1n)) f l2)
    let mapi f l = mapi_with ~base:(Z.of_nativeint 0n) f l
    let rec filter f =
      function
      | [] -> []
      | x::tail ->
          let tail = filter f tail in if f x then x :: tail else tail
      [@@ocaml.doc
        " [filter f l] keeps only the elements of [l] that satisfy [f]. "]
    let rec filter_map f =
      function
      | [] -> []
      | x::tail ->
          let tail = filter_map f tail in
          (match f x with | None -> tail | Some y -> y :: tail)
    let rec flat_map f =
      function | [] -> [] | x::tail -> append (f x) (flat_map f tail)
    let rec find f l =
      match l with | [] -> None | x::tl -> if f x then Some x else find f tl
      [@@ocaml.doc
        " [find f l] returns [Some x] if [x] is the first element of\n      [l] such that [f x] is true. Otherwise it returns [None] "]
    let rec mem x =
      function | [] -> false | y::tail -> (x = y) || (mem x tail)[@@ocaml.doc
                                                                   " [mem x l] returns [true] iff [x] is an element of [l] "]
    let rec mem_assoc x =
      function | [] -> false | (k, _)::tail -> (x = k) || (mem_assoc x tail)
    let rec nth n =
      function
      | [] -> None
      | y::tail ->
          if n = (Z.of_nativeint 0n)
          then Some y
          else nth (n - (Z.of_nativeint 1n)) tail
    let rec assoc x =
      function
      | [] -> None
      | (k, v)::tail -> if x = k then Some v else assoc x tail
    let rec bounded_recons n l =
      if n <= (Z.of_nativeint 0n)
      then []
      else
        (match l with
         | [] -> []
         | hd::tl -> hd :: (bounded_recons (n - (Z.of_nativeint 1n)) tl))
      [@@ocaml.doc
        " Like [take n l], but measured subset is [n] instead of [l]. "]
    let rec take n =
      function
      | [] -> []
      | _ when n <= (Z.of_nativeint 0n) -> []
      | x::tl -> x :: (take (n - (Z.of_nativeint 1n)) tl)[@@ocaml.doc
                                                           " [take n l] returns a list composed of the first (at most) [n] elements\n      of [l]. If [length l <= n] then it returns [l] "]
    let rec drop n =
      function
      | [] -> []
      | l when n <= (Z.of_nativeint 0n) -> l
      | _::tl -> drop (n - (Z.of_nativeint 1n)) tl[@@ocaml.doc
                                                    " [drop n l] returns [l] where the first (at most) [n] elements\n      have been removed. If [length l <= n] then it returns [[]] "]
    let rec (--) i j =
      if i >= j then [] else i :: ((i + (Z.of_nativeint 1n)) -- j)[@@ocaml.doc
                                                                    " Integer range. [i -- j] is the list [[i; i+1; i+2; \226\128\166; j-1]].\n      Returns the empty list if [i >= j]. "]
    let rec insert_sorted ~leq  x l =
      match l with
      | [] -> [x]
      | y::_ when leq x y -> x :: l
      | y::tail -> y :: (insert_sorted ~leq x tail)[@@ocaml.doc
                                                     " Insert [x] in [l], keeping [l] sorted. "]
    let sort ~leq  l =
      (fold_left (fun acc -> fun x -> insert_sorted ~leq x acc) [] l : 
      _ list)[@@ocaml.doc " Basic sorting function "]
    let rec is_sorted ~leq  =
      function
      | [] | _::[] -> true
      | x::(y::_ as tail) -> (leq x y) && (is_sorted ~leq tail)[@@ocaml.doc
                                                                 " Check whether a list is sorted, using the [leq] small-or-equal-than\n      predicatet "]
    let monoid_product l1 l2 =
      flat_map (fun x -> map (fun y -> (x, y)) l2) l1
    let (>|=) o f = map f o
    let (>>=) o f = flat_map f o
    let (let+) = (>|=)
    let (and+) = monoid_product
    let ( let* ) = (>>=)
    let ( and* ) = monoid_product
  end[@@ocaml.doc
       " {2 List module}\n\n    This module contains many safe functions for manipulating lists.\n"]
#772 "prelude.iml"
let (@) = List.append[@@ocaml.doc " Infix alias to {!List.append} "]
#775 "prelude.iml"
let (--) = List.(--)[@@ocaml.doc " Alias to {!List.(--)} "]
#777 "prelude.iml"
module Int =
  struct
    type t = int
    let (+) = (+)
    let (-) = (-)
    let (~-) = (~-)
    let ( * ) = ( * )
    let (/) = (/)
    let (mod) = (mod)
    let (<) = (<)
    let (<=) = (<=)
    let (>) = (>)
    let (>=) = (>=)
    let min = min
    let max = max
    let abs = abs
    let to_string : t -> string = Z.to_string[@@ocaml.doc
                                               " Conversion to a string.\n      Only works for nonnegative numbers "]
    let compare (x : t) (y : t) =
      if x = y
      then Z.of_nativeint 0n
      else if x < y then Z.of_nativeint (-1n) else Z.of_nativeint 1n
    let equal = (=)
    let compare = Stdlib.compare[@@program ]
    let pp = Z.pp_print[@@program ]
    let of_caml_int = Z.of_int[@@program ]
    let rec for_ i j f =
      (if i <= j then (f i; for_ (i + (Z.of_nativeint 1n)) j f) : unit)
      [@@program ]
    let rec for_down_to i j f =
      (if i >= j then (f i; for_down_to (i - (Z.of_nativeint 1n)) j f) : 
      unit)[@@program ]
  end
#828 "prelude.iml"
module Bool = struct type t = bool end
#835 "prelude.iml"
module Array =
  struct
    include Caml.Array[@@ocaml.doc
                        " A program-mode imperative array, that can be mutated "]
    let get a i = Caml.Array.get a (Z.to_int i)
    let set a i v = Caml.Array.set a (Z.to_int i) v
    let make i x = Caml.Array.make (Z.to_int i) x
    let init i f = Caml.Array.init (Z.to_int i) (fun i -> f (Z.of_int i))
    let sub a i len = Caml.Array.sub a (Z.to_int i) (Z.to_int len)
    let length a = Z.of_int (Caml.Array.length a)
    let mapi f a = Caml.Array.mapi (fun i -> fun x -> f (Z.of_int i) x) a
    let iteri f a = Caml.Array.iteri (fun i -> fun x -> f (Z.of_int i) x) a
    let fill a i len x = Caml.Array.fill a (Z.to_int i) (Z.to_int len) x
    let blit a i b j len =
      Caml.Array.blit a (Z.to_int i) b (Z.to_int j) (Z.to_int len)
  end[@@ocaml.doc " {2 Arrays}\n\n   Program mode only "][@@program ]
#857 "prelude.iml"
module Option =
  struct
    type 'a t = 'a option
    let map f = function | None -> None | Some x -> Some (f x)[@@ocaml.doc
                                                                " Map over the option.\n\n      - [map f None = None]\n      - [map f (Some x) = Some (f x)]\n  "]
    let map_or ~default  f = function | None -> default | Some x -> f x
    let is_some = function | None -> false | Some _ -> true[@@ocaml.doc
                                                             " Returns [true] iff the argument is of the form [Some x] "]
    let is_none = function | None -> true | Some _ -> false[@@ocaml.doc
                                                             " Returns [true] iff the argument is [None] "]
    let return x = Some x[@@ocaml.doc
                           " Wrap a value into an option. [return x = Some x] "]
    let (>|=) x f = map f x[@@ocaml.doc " Infix alias to {!map} "]
    let flat_map f o = match o with | None -> None | Some x -> f x[@@ocaml.doc
                                                                    " Monadic operator, useful for chaining multiple optional computations "]
    let (>>=) o f = flat_map f o[@@ocaml.doc
                                  " Infix monadic operator, useful for chaining multiple optional computations\n      together.\n      It holds that [(return x >>= f) = f x] "]
    let or_ ~else_  a = match a with | None -> else_ | Some _ -> a[@@ocaml.doc
                                                                    " Choice of a value\n\n      - [or_ ~else_:x None = x]\n      - [or_ ~else_:x (Some y) = Some y]\n  "]
    let (<+>) a b = or_ ~else_:b a
    let exists p = function | None -> false | Some x -> p x
    let for_all p = function | None -> true | Some x -> p x
    let get_or ~default  x = match x with | None -> default | Some y -> y
    let fold f acc o = match o with | None -> acc | Some x -> f acc x
    let (<$>) = map[@@ocaml.doc " [f <$> x = map f x] "]
    let monoid_product a b =
      match (a, b) with | (Some x, Some y) -> Some (x, y) | _ -> None
    let (let+) = (>|=)
    let (and+) = monoid_product
    let ( let* ) = (>>=)
    let ( and* ) = monoid_product
  end[@@ocaml.doc
       " {2 Option module}\n\n    The option type [type 'a option = None | Some of 'a] is useful for\n    representing partial functions and optional values.\n    "]
#950 "prelude.iml"
module Real :
  sig
    type t = real
    val of_int : int -> t
    [@@@ocaml.text "/*"]
    val _to_int_round_down : t -> int
    [@@@ocaml.text "/*"]
    val to_int : t -> int
    val (+) : t -> t -> t
    val (-) : t -> t -> t
    val (~-) : t -> t
    val ( * ) : t -> t -> t
    val (/) : t -> t -> t
    val (<) : t -> t -> bool
    val (<=) : t -> t -> bool
    val (>) : t -> t -> bool
    val (>=) : t -> t -> bool
    val abs : t -> t
    val min : t -> t -> t
    val max : t -> t -> t
    val mk_of_float : float -> t
    val mk_of_q : t -> t
    val mk_of_string : string -> t
    val to_float : t -> float
    val of_float : float -> t
    val compare : t -> t -> Caml.Int.t
    val pp : Format.formatter -> t -> unit
    val to_string : t -> string
    val to_string_approx : t -> string
  end =
  struct
    type t = real
    let of_int : int -> t = Q.of_bigint
    let _to_int_round_down : t -> int = Q.to_bigint
    let to_int (r : t) =
      (if r >=. (of_int (Z.of_nativeint 0n))
       then _to_int_round_down r
       else - (_to_int_round_down (-. r)) : int)
    let (+) = (+.)
    let (-) = (-.)
    let (~-) = (~-.)
    let ( * ) = ( *. )
    let (/) = (/.)
    let (<) = (<.)
    let (<=) = (<=.)
    let (>) = (>.)
    let (>=) = (>=.)
    let abs r = if r >= (of_int (Z.of_nativeint 0n)) then r else - r
    let min = min_r
    let max = max_r
    let mk_of_float = Q.of_float[@@program ]
    let mk_of_q (x : Q.t) = x[@@program ]
    let mk_of_string (x : string) = Q.of_string x[@@program ]
    let to_float = Q.to_float[@@program ]
    let of_float = Q.of_float
    let compare (x : t) (y : t) =
      if x = y then 0 else if x < y then (-1) else 1[@@program ]
    let pp = Q.pp_print[@@program ]
    let to_string = Q.to_string[@@program ]
    let to_string_approx x = string_of_float @@ (Q.to_float x)[@@program ]
  end 
#1027 "prelude.iml"
module Map :
  sig
    type (+'a, 'b) t
    val const : 'b -> (_, 'b) t
    val add : 'a -> 'b -> ('a, 'b) t -> ('a, 'b) t
    val add' : ('a, 'b) t -> 'a -> 'b -> ('a, 'b) t
    val get : 'a -> ('a, 'b) t -> 'b
    val get' : ('a, 'b) t -> 'a -> 'b
    val get_default : (_, 'b) t -> 'b
    val of_list : default:'b -> ('a * 'b) list -> ('a, 'b) t
    val filter_map :
      default:('b -> 'c) ->
        f:('a -> 'b -> 'c option) -> ('a, 'b) t -> ('a, 'c) t[@@program ]
    val for_all :
      default:('b -> bool) -> f:('a -> 'b -> bool) -> ('a, 'b) t -> bool
    [@@program ]
    val merge :
      default:('b -> 'c -> 'd) ->
        f_both:('a -> 'b -> 'c -> 'd option) ->
          f1:('a -> 'b -> 'd option) ->
            f2:('a -> 'c -> 'd option) ->
              ('a, 'b) t -> ('a, 'c) t -> ('a, 'd) t[@@program ]
    val extract : ('a, 'b) t -> (('a * 'b) list * 'b)[@@program ]
    val pp : 'a printer -> 'b printer -> ('a, 'b) t printer[@@program ]
  end =
  struct
    type (+'a, 'b) t = {
      l: ('a * 'b) list ;
      default: 'b }
    let const x = ({ default = x; l = [] } : _ t)
    let add_rec k v m =
      (let rec aux l =
         match l with
         | [] -> if v = m.default then [] else [(k, v)]
         | (k', v')::tail ->
             (match Caml.compare k k' with
              | 0 -> if v = m.default then tail else (k, v) :: tail
              | n when let open Caml.Int in n < 0 ->
                  if v = m.default then l else (k, v) :: l
              | _ -> (k', v') :: (aux tail)) in
       { m with l = (aux m.l) } : _ t)[@@program ]
    let add' m k v = add_rec k v m[@@ocaml.doc
                                    " [add' m k v] adds the binding [k -> v] to [m] "]
    let add k v m = add' m k v[@@ocaml.doc
                                " Same as {!add'} but with arguments swapped "]
    let get_default (m : (_, 'b) t) = (m.default : 'b)
    let get_rec k m =
      let rec aux l =
        match l with
        | [] -> m.default
        | (k', v)::tail -> if k = k' then v else aux tail in
      aux m.l[@@program ]
    let get' m k = get_rec k m
    let get (k : 'a) (m : ('a, 'b) t) = (get' m k : 'b)
    let rec of_list ~default:(default : 'b)  (l : ('a * 'b) list) =
      (match l with
       | [] -> const default
       | (k, v)::tail -> add k v (of_list ~default tail) : ('a, 'b) t)
    let filter_map ~default  ~f  m =
      (let rec aux =
         function
         | [] -> []
         | (x, v)::tl ->
             let tl = aux tl in
             (match f x v with | None -> tl | Some v' -> (x, v') :: tl) in
       { default = (default m.default); l = (aux m.l) } : _ t)[@@program ]
    let for_all ~default  ~f  m =
      ((default m.default) && (List.for_all (fun (x, v) -> f x v) m.l) : 
      bool)[@@program ]
    let merge ~default  ~f_both  ~f1  ~f2  (s1 : ('a, 'b) t)
      (s2 : ('a, 'c) t) =
      (let open Stdlib in
         let rec aux l1 l2 =
           match (l1, l2) with
           | ([], []) -> []
           | ([], _) ->
               CCList.filter_map
                 (fun (k, v) -> (CCOption.map (fun v -> (k, v))) @@ (f2 k v))
                 l2
           | (_, []) ->
               CCList.filter_map
                 (fun (k, v) -> (CCOption.map (fun v -> (k, v))) @@ (f1 k v))
                 l1
           | ((x1, v1)::tl1, (x2, v2)::tl2) ->
               if x1 = x2
               then
                 let tl = aux tl1 tl2 in
                 (match f_both x1 v1 v2 with
                  | None -> tl
                  | Some v -> (x1, v) :: tl)
               else
                 if x1 < x2
                 then
                   (let tl = aux tl1 l2 in
                    match f1 x1 v1 with
                    | None -> tl
                    | Some v -> (x1, v) :: tl)
                 else
                   (let tl = aux l1 tl2 in
                    match f2 x2 v2 with
                    | None -> tl
                    | Some v -> (x2, v) :: tl) in
         { default = (default s1.default s2.default); l = (aux s1.l s2.l) } : 
      ('a, 'd) t)[@@program ]
    let extract (m : ('a, 'b) t) =
      (((m.l), (m.default)) : (('a * 'b) list * 'b))[@@program ]
    let pp pp_k pp_v out (m : (_, _) t) =
      (match m.l with
       | [] -> Format.fprintf out "(@[Map.const %a@])" pp_v m.default
       | _ ->
           let pp_sep out () = Format.fprintf out ";@ " in
           let pp_pair out (k, v) =
             Format.fprintf out "(@[%a,@ %a@])" pp_k k pp_v v in
           Format.fprintf out "(@[Map.of_list@ ~default:%a@ [@[%a@]]@])" pp_v
             m.default (Format.pp_print_list ~pp_sep pp_pair) m.l : unit)
      [@@program ]
  end 
#1183 "prelude.iml"
module Multiset :
  sig
    type +'a t = ('a, int) Map.t
    val empty : 'a t
    val add : 'a -> 'a t -> 'a t
    val remove : 'a -> 'a t -> 'a t
    val mem : 'a -> 'a t -> bool
    val find : 'a -> 'a t -> int
    val of_list : 'a list -> 'a t
  end =
  struct
    type +'a t = ('a, int) Map.t
    let empty = Map.const (Z.of_nativeint 0n)
    let add (x : 'a) (m : 'a t) =
      (Map.add x ((Map.get x m) + (Z.of_nativeint 1n)) m : 'a t)
    let find = Map.get
    let mem x m = ((find x m) > (Z.of_nativeint 0n) : bool)
    let remove (x : 'a) (m : 'a t) =
      (let n = max (Z.of_nativeint 0n) ((Map.get x m) - (Z.of_nativeint 1n)) in
       Map.add x n m : 'a t)
    let rec of_list =
      function | [] -> empty | x::tail -> (add x) @@ (of_list tail)
  end [@@ocaml.doc
        " {2 Multiset}\n\n    A multiset is a collection of elements that don't have any particular\n    order, but can occur several times (unlike a regular set). "]
#1209 "prelude.iml"
[@@@ocaml.text " {2 Sets} "]
#1211 "prelude.iml"
module Set :
  sig
    type +'a t = ('a, bool) Map.t
    val empty : 'a t
    val is_valid : _ t -> bool
    val is_empty : _ t -> bool
    val mem : 'a -> 'a t -> bool
    val add : 'a -> 'a t -> 'a t
    val remove : 'a -> 'a t -> 'a t
    val subset : 'a t -> 'a t -> bool
    val union : 'a t -> 'a t -> 'a t
    val complement : 'a t -> 'a t
    val inter : 'a t -> 'a t -> 'a t
    val diff : 'a t -> 'a t -> 'a t
    val (++) : 'a t -> 'a t -> 'a t
    val (--) : 'a t -> 'a t -> 'a t
    val of_list : 'a list -> 'a t
    val to_list : 'a t -> 'a list
    val pp : 'a printer -> 'a t printer
  end =
  struct
    type +'a t = ('a, bool) Map.t
    let empty = Map.const false
    let is_empty s = s = empty
    let is_valid s = not (Map.get_default s)
    let mem x s = Map.get x s
    let subset (s1 : 'a t) (s2 : 'a t) =
      (Map.for_all s1
         ~default:(fun v1 -> if v1 then Map.get_default s2 else true)
         ~f:(fun x -> fun v1 -> if v1 then mem x s2 else true) : bool)
    let add x s = Map.add x true s
    let remove x s = Map.add x false s
    let inter_ (s1 : 'a t) (s2 : 'a t) =
      (Map.merge s1 s2
         ~default:(fun v1 ->
                     fun v2 -> assert (not v1); assert (not v2); false)
         ~f1:(fun _ -> fun _ -> None) ~f2:(fun _ -> fun _ -> None)
         ~f_both:(fun _ ->
                    fun s1 -> fun s2 -> if s1 && s2 then Some true else None) : 
      'a t)[@@program ]
    let inter = inter_
    let union_ (s1 : 'a t) (s2 : 'a t) =
      (Map.merge
         ~default:(fun v1 ->
                     fun v2 -> assert (not v1); assert (not v2); false)
         ~f1:(fun _ -> fun _ -> Some true) ~f2:(fun _ -> fun _ -> Some true)
         ~f_both:(fun _ ->
                    fun s1 -> fun s2 -> if s1 || s2 then Some true else None)
         s1 s2 : 'a t)[@@program ]
    let union = union_
    let complement_ (_s : 'a t) = (failwith "complement" : 'a t)[@@program ]
    let complement = complement_
    let diff_ (s1 : 'a t) (s2 : 'a t) =
      (Map.merge
         ~default:(fun v1 ->
                     fun v2 -> assert (not v1); assert (not v2); false)
         ~f1:(fun _ -> fun _ -> Some true) ~f2:(fun _ -> fun _ -> None)
         ~f_both:(fun _ ->
                    fun s1 ->
                      fun s2 -> if s1 && (not s2) then Some true else None)
         s1 s2 : 'a t)[@@program ]
    let diff = diff_
    let rec of_list = function | [] -> empty | x::tl -> add x (of_list tl)
    let to_list (s : 'a t) =
      (let (l, _) = Map.extract s in
       CCList.filter_map (fun (x, b) -> if b then Some x else None) l : 
      'a list)[@@program ]
    let (++) = union
    let (--) = diff
    let pp pp_x out (x : 'a t) =
      (match to_list x with
       | [] -> Format.pp_print_string out "Set.empty"
       | l ->
           Format.fprintf out "(@[Set.of_list@ [@[%a@]]@])"
             (Format.pp_print_list
                ~pp_sep:(fun out -> fun () -> Format.fprintf out ";@ ") pp_x)
             l : unit)[@@program ]
  end 
#1340 "prelude.iml"
module String :
  sig
    type t = string
    val empty : t
    val length : t -> int
    val make : Caml.Int.t -> char -> t
    val append : t -> t -> t
    val get : t -> Caml.Int.t -> char
    val concat : t -> t list -> t
    val prefix : t -> t -> bool
    val suffix : t -> t -> bool
    val contains : t -> sub:t -> bool
    val unsafe_sub : t -> int -> int -> t
    val sub : t -> int -> int -> t option
    val of_int : int -> t
    val to_int : t -> int option
    val is_int : t -> bool
    val is_nat : t -> bool
    val to_nat : t -> int option
    [@@@ocaml.text "/*"]
    val unsafe_to_nat : t -> int
    val unsafe_to_int : t -> int
    [@@@ocaml.text "/*"]
  end =
  struct
    type t = string
    let empty = ""
    let length (s : t) = (Z.of_int (Caml.String.length s) : int)[@@ocaml.doc
                                                                  " Length of the string, i.e. its number of bytes "]
    let make (i : Caml.Int.t) c = (String.make i c : t)[@@ocaml.doc
                                                         " [make i c] makes a string containing [i] times the char [c] "]
      [@@program ]
    let append : t -> t -> t = Stdlib.(^)[@@ocaml.doc
                                           " String concatenation "]
    let get = Caml.String.get[@@program ]
    let rec concat sep (l : t list) =
      (match l with
       | [] -> ""
       | x::[] -> x
       | x::tail -> append x (append sep (concat sep tail)) : t)[@@ocaml.doc
                                                                  " [concat sep l] concatenates strings in [l] with [sep] inserted between\n    each element.\n\n    - [concat sep [] = \"\"]\n    - [concat sep [x] = x]\n    - [concat sep [x;y] = x ^ sep ^ y]\n    - [concat sep (x :: tail) = x ^ sep ^ concat sep tail]\n    "]
    let prefix a b = Caml.String.prefix a b[@@ocaml.doc
                                             " [prefix a b] returns [true] iff [a] is a prefix of [b]\n      (or if [a=b] "]
    let suffix a b = Caml.String.suffix a b[@@ocaml.doc
                                             " [suffix a b] returns [true] iff [a] is a suffix of [b]\n      (or if [a=b] "]
    let contains a ~sub  = (Caml.String.contains a ~sub : bool)
    let unsafe_sub (a : t) (i : int) (len : int) =
      (Caml.String.sub a (Z.to_int i) (Z.to_int len) : t)
    let sub (a : t) (i : int) (len : int) =
      (if
         (i >= (Z.of_nativeint 0n)) &&
           ((len >= (Z.of_nativeint 0n)) && ((i + len) <= (length a)))
       then Some (unsafe_sub a i len)
       else None : t option)[@@ocaml.doc
                              " Substring. [sub s i len] returns the string [s[i], s[i+1],\226\128\166,s[i+len-1]]. "]
    let of_int (i : int) =
      (if i >= (Z.of_nativeint 0n)
       then Int.to_string i
       else append "-" (Int.to_string (- i)) : t)[@@ocaml.doc
                                                   " String representation of an integer "]
    let unsafe_to_nat : t -> int = Caml.String.unsafe_to_nat
    let to_nat (s : t) =
      (let x = unsafe_to_nat s in
       if x >= (Z.of_nativeint 0n) then Some x else None : int option)
      [@@ocaml.doc
        " Parse a string into a nonnegative number, or return [None] "]
    let is_nat (s : t) =
      ((s <> "") && ((unsafe_to_nat s) >= (Z.of_nativeint 0n)) : bool)
    let is_int (s : t) =
      ((is_nat s) ||
         ((prefix "-" s) &&
            (is_nat
               (unsafe_sub s (Z.of_nativeint 1n)
                  ((length s) - (Z.of_nativeint 1n))))) : bool)
    let unsafe_to_int (s : t) =
      (let x = unsafe_to_nat s in
       if x >= (Z.of_nativeint 0n)
       then x
       else
         -
           (unsafe_to_nat
              (unsafe_sub s (Z.of_nativeint 1n)
                 ((length s) - (Z.of_nativeint 1n)))) : int)
    let to_int (s : t) =
      (if is_int s then Some (unsafe_to_int s) else None : int option)
  end [@@ocaml.doc
        " {2 Byte strings}\n\n    These strings correspond to OCaml native strings, and do not have\n    a particular unicode encoding.\n\n    Rather, they should be seen as sequences of bytes, and it is also\n    this way that Imandra considers them.\n"]
#1449 "prelude.iml"
let (^) = String.append[@@ocaml.doc " Alias to {!String.append} "]
#1452 "prelude.iml"
let succ x = x + (Z.of_nativeint 1n)[@@ocaml.doc " Next integer "]
#1455 "prelude.iml"
let pred x = x - (Z.of_nativeint 1n)[@@ocaml.doc " Previous integer "]
#1457 "prelude.iml"
let fst (x, _) = x
#1458 "prelude.iml"
let snd (_, y) = y
#1460 "prelude.iml"
module Float =
  struct
    type t = float
    module Round : sig type t end =
      struct
        type t =
          | Nearest_ties_to_even [@ocaml.doc " default "]
          | Nearest_ties_to_away 
          | Towards_positive 
          | Towards_negative 
          | Towards_zero 
        let _ = fun (x : t) -> x = x[@@imandra_verify ]
      end 
    let of_int = Z.to_float[@@program ]
    let of_string = Caml.float_of_string[@@program ]
    let (~-) : t -> t = Caml.(~-.)
    let (+) : t -> t -> t = Caml.(+.)
    let (-) : t -> t -> t = Caml.(-.)
    let ( * ) : t -> t -> t = Caml.( *. )
    let (/) : t -> t -> t = Caml.(/.)
    let nan : t = Caml.nan
    let infinity : t = Caml.infinity
    let (<) : t -> t -> bool = Caml.(<)
    let (<=) : t -> t -> bool = Caml.(<=)
    let (>) : t -> t -> bool = Caml.(>)
    let (>=) : t -> t -> bool = Caml.(>=)
    let (=) : t -> t -> bool = Caml.(=)
    let (<>) : t -> t -> bool = Caml.(<>)
    let neg : t -> t = (~-)
    let abs : t -> t = Caml.abs_float
    let is_zero (x : t) = (Stdlib.(=) x (Caml.float_of_string "0.") : bool)
    let is_nan (x : t) =
      (Stdlib.(=) (Caml.classify_float x) Caml.FP_nan : bool)
    let is_infinite (x : t) =
      (Stdlib.(=) (Caml.classify_float x) Caml.FP_infinite : bool)
    let is_normal (x : t) =
      (Stdlib.(=) (Caml.classify_float x) Caml.FP_normal : bool)
    let is_subnormal (x : t) =
      (Stdlib.(=) (Caml.classify_float x) Caml.FP_subnormal : bool)
    let is_positive (x : t) = (x > (Caml.float_of_string "0.") : bool)
    let is_negative (x : t) = (x < (Caml.float_of_string "0.") : bool)
    let min (x : t) (y : t) =
      (if is_nan x then y else if is_nan y then x else Caml.min x y : 
      t)
    let max (x : t) (y : t) =
      (if is_nan x then y else if is_nan y then x else Caml.max x y : 
      t)
    let rem : t -> t -> t = Caml.mod_float
    let sqrt : t -> t = Caml.sqrt
  end
#1525 "prelude.iml"
module LChar =
  struct
    type t =
      | Char of bool * bool * bool * bool * bool * bool * bool * bool 
    let zero : t =
      Char (false, false, false, false, false, false, false, false)
    let to_int (c : t) =
      (let open Caml.Int in
         let Char (a7, a6, a5, a4, a3, a2, a1, a0) = c in
         let (!) x = if x then 1 else 0 in
         ((((((((!a7) lsl 7) + ((!a6) lsl 6)) + ((!a5) lsl 5)) +
               ((!a4) lsl 4))
              + ((!a3) lsl 3))
             + ((!a2) lsl 2))
            + ((!a1) lsl 1))
           + ((!a0) lsl 0) : Caml.Int.t)[@@program ]
    let of_int (i : Caml.Int.t) =
      (assert ((let open Caml.Int in (i >= 0) && (i < 128)));
       (let (!) x = x <> 0 in
        let a7 = !(i land (1 lsl 7)) in
        let a6 = !(i land (1 lsl 6)) in
        let a5 = !(i land (1 lsl 5)) in
        let a4 = !(i land (1 lsl 4)) in
        let a3 = !(i land (1 lsl 3)) in
        let a2 = !(i land (1 lsl 2)) in
        let a1 = !(i land (1 lsl 1)) in
        let a0 = !(i land (1 lsl 0)) in Char (a7, a6, a5, a4, a3, a2, a1, a0)) : 
      t)[@@program ]
    let of_char (c : char) = (of_int (Caml.Char.code c) : t)[@@program ]
    let to_char (c : t) = (Caml.Char.chr (to_int c) : char)[@@program ]
    let pp out c = Format.fprintf out "%C" (to_char c)[@@program ]
    let explode (s : string) =
      (let l = ref [] in
       Caml.String.iter (fun c -> l := ((of_char c) :: (!l))) s;
       List.rev (!l) : t list)[@@program ]
    let is_printable (c : t) =
      (match c with
       | Char (false, false, true, false, false, false, false, false) ->
           false
       | Char (_, true, _, _, _, _, _, _) | Char (_, _, true, _, _, _, _, _)
           -> true
       | _ -> false : bool)
  end[@@ocaml.doc " {1 Logic mode char}\n\n    An 8-bit char. "]
#1581 "prelude.iml"
[@@@ocaml.text " {2 Logic-mode strings}\n\n    Strings purely in Imandra. "]
#1585 "prelude.iml"
module LString =
  struct
    type t = LChar.t list
    let empty : t = []
    let of_list l = l
    let to_string (s : t) = (CCList.map LChar.to_char s) |> CCString.of_list
      [@@program ]
    let of_string = LChar.explode[@@program ]
    let rec length (s : t) =
      match s with
      | [] -> Z.of_nativeint 0n
      | _::tl -> (Z.of_nativeint 1n) + (length tl)[@@unroll 32]
    let pp out l =
      if List.for_all LChar.is_printable l
      then
        Format.fprintf out "{l|@[<hov>%s@]|l}"
          ((CCList.map LChar.to_char l) |> CCString.of_list)
      else CCFormat.Dump.list LChar.pp out l[@@program ]
    let len_pos (s : t) = ((length s)[@trigger ]) >= (Z.of_nativeint 0n)
      [@@imandra_theorem ][@@auto ][@@fc ]
    let len_zero_inversion (s : t) =
      implies (((length s)[@trigger ]) = (Z.of_nativeint 0n)) (s = [])
      [@@imandra_theorem ][@@auto ][@@fc ]
    let rec append (s1 : t) (s2 : t) =
      (match s1 with | [] -> s2 | c::s1' -> c :: (append s1' s2) : t)
    let (^^) = append
    let rec for_all f (s : t) =
      match s with | [] -> true | x::tl -> (f x) && (for_all f tl)[@@unroll
                                                                    32]
    let rec exists f (s : t) =
      match s with | [] -> false | x::tl -> (f x) || (exists f tl)[@@unroll
                                                                    32]
    let rec concat sep =
      function
      | [] -> []
      | s::[] -> s
      | s1::tl -> append s1 (append sep (concat sep tl))
    let is_printable (s : t) = (for_all LChar.is_printable s : bool)
    let rec sub (s : t) (i : int) (len : int) =
      (match s with
       | [] -> []
       | c1::s' ->
           if len <= (Z.of_nativeint 0n)
           then []
           else
             if i <= (Z.of_nativeint 0n)
             then c1 ::
               (sub s' (Z.of_nativeint 0n) (len - (Z.of_nativeint 1n)))
             else sub s' (i - (Z.of_nativeint 1n)) len : t)
    let rec prefix (s1 : t) (s2 : t) =
      (match s1 with
       | [] -> true
       | c1::s1' ->
           (match s2 with
            | [] -> false
            | c2::s2' -> (c1 = c2) && (prefix s1' s2')) : bool)
    let rec suffix (s1 : t) (s2 : t) =
      ((s1 = s2) || (match s2 with | [] -> false | _::s2' -> suffix s1 s2') : 
      bool)
    let rec contains ~sub:(s1 : t)  (s2 : t) =
      (match s1 with
       | [] -> true
       | c1::s1' ->
           (match s2 with
            | [] -> false
            | c2::s2' ->
                ((c1 = c2) && (contains ~sub:s1' s2')) ||
                  (contains ~sub:s1 s2')) : bool)
    let take : int -> t -> t = List.take
    let drop : int -> t -> t = List.drop
  end
#1687 "prelude.iml"
module Pervasives = struct  end
#1688 "prelude.iml"
module Stdlib = struct  end

